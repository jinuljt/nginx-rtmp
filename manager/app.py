import json
import subprocess
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List
from urllib import error as urlerror
from urllib import request as urlrequest

from flask import Flask, flash, redirect, render_template, request, url_for

DATA_PATH = Path("/var/lib/nginx-manager/push_sources.json")
CONF_PATH = Path("/etc/nginx/conf.d/rtmp_pushes.conf")
STAT_ENDPOINT = "http://127.0.0.1:8080/rtmp_stat"


def _ensure_storage() -> None:
    DATA_PATH.parent.mkdir(parents=True, exist_ok=True)
    if not DATA_PATH.exists():
        DATA_PATH.write_text("[]", encoding="utf-8")
    CONF_PATH.parent.mkdir(parents=True, exist_ok=True)
    if not CONF_PATH.exists():
        CONF_PATH.write_text("# Generated by the RTMP manager\n", encoding="utf-8")


def load_sources() -> List[str]:
    _ensure_storage()
    try:
        return json.loads(DATA_PATH.read_text(encoding="utf-8"))
    except json.JSONDecodeError:
        return []


def persist_sources(sources: List[str]) -> None:
    previous_data = DATA_PATH.read_text(encoding="utf-8") if DATA_PATH.exists() else "[]"
    previous_conf = CONF_PATH.read_text(encoding="utf-8") if CONF_PATH.exists() else ""

    DATA_PATH.write_text(json.dumps(sources, indent=2, ensure_ascii=False), encoding="utf-8")
    lines = ["# Managed automatically; changes will be overwritten.\n"]
    for url in sources:
        lines.append(f"push {url};\n")
    CONF_PATH.write_text("".join(lines), encoding="utf-8")

    try:
        subprocess.run(["nginx", "-s", "reload"], check=True)
    except subprocess.CalledProcessError as exc:
        DATA_PATH.write_text(previous_data, encoding="utf-8")
        CONF_PATH.write_text(previous_conf, encoding="utf-8")
        raise RuntimeError("重新加载 Nginx 失败，请检查配置。") from exc


def safe_int(value: str, default: int = 0) -> int:
    try:
        return int(value)
    except (TypeError, ValueError):
        return default


def safe_float(value: str, default: float = 0.0) -> float:
    try:
        return float(value)
    except (TypeError, ValueError):
        return default


def format_duration(seconds: int) -> str:
    total = max(0, seconds)
    days, remainder = divmod(total, 86400)
    hours, remainder = divmod(remainder, 3600)
    minutes, secs = divmod(remainder, 60)
    parts: List[str] = []
    if days:
        parts.append(f"{days}d")
    if hours or parts:
        parts.append(f"{hours}h")
    if minutes or parts:
        parts.append(f"{minutes}m")
    parts.append(f"{secs}s")
    return " ".join(parts)


def fetch_rtmp_stats() -> Dict[str, object]:
    try:
        with urlrequest.urlopen(STAT_ENDPOINT, timeout=3) as response:
            payload = response.read()
    except urlerror.URLError as exc:
        raise RuntimeError("无法获取 Nginx RTMP 状态，请确认服务已启动。") from exc

    try:
        root = ET.fromstring(payload)
    except ET.ParseError as exc:
        raise RuntimeError("Nginx RTMP 状态数据格式不正确。") from exc

    server_node = root.find("server")
    if server_node is None:
        return {"uptime": "0s", "nclients": 0, "streams_total": 0, "applications": []}

    uptime = format_duration(safe_int(server_node.findtext("uptime")))
    nclients = safe_int(server_node.findtext("nclients"))

    applications: List[Dict[str, object]] = []
    streams_total = 0

    for app in server_node.findall("application"):
        app_name = app.findtext("name") or "default"
        live = app.find("live")
        stream_rows: List[Dict[str, object]] = []
        if live is not None:
            for stream in live.findall("stream"):
                stream_rows.append(
                    {
                        "app": app_name,
                        "name": stream.findtext("name") or "unnamed",
                        "time": format_duration(safe_int(stream.findtext("time"))),
                        "clients": safe_int(stream.findtext("nclients")),
                        "bw_in": safe_float(stream.findtext("bw_in")),
                        "bw_out": safe_float(stream.findtext("bw_out")),
                        "bytes_in": safe_float(stream.findtext("bytes_in")),
                        "bytes_out": safe_float(stream.findtext("bytes_out")),
                    }
                )
        streams_total += len(stream_rows)
        applications.append({"name": app_name, "streams": stream_rows})

    return {
        "uptime": uptime,
        "nclients": nclients,
        "streams_total": streams_total,
        "applications": applications,
    }


def normalise_url(url: str) -> str:
    trimmed = url.strip()
    return trimmed.rstrip("/")


app = Flask(__name__)
app.secret_key = "rtmp-manager"
app.config["JSON_SORT_KEYS"] = False


@app.route("/", methods=["GET"])
def index():
    sources = load_sources()
    return render_template("index.html", sources=sources)


@app.route("/add", methods=["POST"])
def add_source():
    raw_url = request.form.get("push_url", "")
    if not raw_url:
        flash("推送地址不能为空。", "error")
        return redirect(url_for("index"))

    url = normalise_url(raw_url)
    if not url.startswith(("rtmp://", "rtmps://")):
        flash("仅支持 rtmp:// 或 rtmps:// 开头的地址。", "error")
        return redirect(url_for("index"))

    sources = load_sources()
    if url in sources:
        flash("该推送源已存在。", "info")
        return redirect(url_for("index"))

    sources.append(url)
    try:
        persist_sources(sources)
    except RuntimeError as exc:
        flash(str(exc), "error")
        return redirect(url_for("index"))
    flash("新增推送源成功，Nginx 已重新加载。", "success")
    return redirect(url_for("index"))


@app.route("/delete", methods=["POST"])
def delete_source():
    url = request.form.get("push_url", "")
    sources = load_sources()
    if url not in sources:
        flash("未找到指定的推送源。", "error")
        return redirect(url_for("index"))

    sources = [item for item in sources if item != url]
    try:
        persist_sources(sources)
    except RuntimeError as exc:
        flash(str(exc), "error")
        return redirect(url_for("index"))
    flash("已删除推送源，Nginx 已重新加载。", "success")
    return redirect(url_for("index"))


@app.route("/api/sources", methods=["GET"])
def api_sources():
    return {"sources": load_sources()}


@app.route("/stat", methods=["GET"])
def stat_view():
    error = None
    stats = None
    try:
        stats = fetch_rtmp_stats()
    except RuntimeError as exc:
        error = str(exc)
    return render_template("stat.html", stats=stats, error=error)


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
